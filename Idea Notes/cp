
0. SILLY MISTAKES
   a.> Do not forget to observe the range of input values. Accordingly decide the data type. For example interger can store upto 1e9, long can store upto 1e12 and long long can store upto 1e18.
   b.> Also note that most questions should be solved within 1s of time, which happens only if your max intraion is of the order of 1e7.
   c.> You should also not forget to clear the vector or map after each test case using mp.clear() or arr.clear()
   d.> When you declare int sum; its initial value is indeterminate, meaning it could contain any random value. So initialize it to sum = 0 before proceeding to code logic.
   e.> Store value of boolean expression in bool data type and not in int data type(Example - https://www.codechef.com/START136D/problems/FIRSTGEO)
   f.>We should use int a = s[i] - 'a' to convert the character to an index from 0 to 25 where s[i] is indexing of some string.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1. We can use inbuilt map data structure to store frequency of each element of an array or vector while taking the input from user:-

  https://codeforces.com/problemset/problem/1890/A
  https://codeforces.com/problemset/problem/1807/D

  map<int, int> freq;
        int x;
        for (int i = 0; i < n; ++i)
        {
            cin >> x;
            freq[x]++;
        }
//to find maximum frequency(alternatively we can find key with maximum frequency)
int maxFreq = 0;
        for (auto &[x, y] : freq) {
            maxFreq = max(maxFreq, y);
        }
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2. Sometimes in questions of Yes or No, you do not have to look for every edge case, instead look to more vulnerable one and rest all cases will fall in other one.
  
Example - https://codeforces.com/problemset/problem/1878/A
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3. If you are getting TLE and you think that algo is good, then try applying precomputation technique. It will work sometimes because precomputing at constraind length and storing your answers 
in vector saves much time if compared to brute worst case. By precomputation you are now just required to print you answer only in constant or linear time.
  
Example - https://codeforces.com/problemset/problem/1766/A

BRUTE FORCE:-
while(t--){
    int n;
    cin >> n;
    int count = 0;
    int answer = 0;
    for (int i = 1; i <= n; ++i) {
        count = 0;
        int temp = i;
        while(temp != 0){
            int r = temp % 10;
            if(r != 0){
                count++;
            }
            temp = temp/10;
        }
        if(count == 1){
            answer++;
        }
    }
    cout << answer <<endl;
}
The total time complexity is O(t NlogN) where t is 1e4 and N is 999999 which leads to TLE because 1e7 iterations take about 1second and here is 1e10 iterations
----------------------------------
OPTIMIZED: PRECOMPUTATION

#include<bits/stdc++.h>
using namespace std;
#include<vector>

int compute(int i){
        int count = 0;
        int temp = i;
        while(temp != 0){
            int r = temp % 10;
            if(r != 0){
                count++;
            }
            temp = temp/10;
        }
        return (count == 1);
}

int main() {
    int t;
    cin >> t;
    vector<int> round;
    for (int i = 0; i < 999999; ++i)
    {
        if(compute(i)){
            round.push_back(i);
        }
    }
    
    while(t--){
        int n;
        cin >> n;
        int count = 0;
        for(auto x: round){
            if(x <= n) count++; 
        }
        cout<< count << endl;
    }
}

For each test case, we count how many precomputed numbers are ≤𝑛. This is 𝑂(𝑚), where 𝑚 is the number of precomputed extremely round numbers (a constant, at most 54 for the given range).
Thus, the time complexity per test case is 𝑂(𝑚), and for 𝑡 test cases, the total time complexity is 𝑂(𝑡⋅𝑚). Since 𝑚 is a small constant, this simplifies to 𝑂(𝑡).

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4. TRACKING MAXIMUM SUBARRAY LENGTH SATISFYING SOME CONDITION.
   int ans = 1;
   int count = 1;
   for(int i = 0;i<n; ++i){
      if(condition) count++;
      else count = 1
      ans = max(ans,count);
    }

https://codeforces.com/problemset/problem/1850/D
https://codeforces.com/problemset/problem/1837/B

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
