
1. For questions related to parity(odd, even), try to come up with solution by analyzing odd as 1 and even as 0. For example in an array having even frequency of odd numbers, it is always
  possible to divide array in two parts such that sum of both parts will have same parity.

  EXAMPLE - https://codeforces.com/problemset/problem/1857/A
  In case of binary string, if you replace 0 with -1 and 1 with 1, then substring which makes sum 0 is having same number of 0 and 1.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. To find the length of largest interval  [l,r](which isr-l+1) of positive integers(consecutive) such that, for every i in the interval (i.e., l≤i≤r), n is a multiple of i or i is a factor of n,
   we will simplify the problem by focussing on intervals starting from 1. If you find smallest integer x that does not divide n then the length of interval [1, x-1] which is ((x-1) - 1 +1) = x-1
   is the required length.
   In other words among a list of factors of a numbers, chances of getting maximum length of consecutive factors that divide a number is good if we start from beginning, this is because as 
   we move ahead difference between factors increase. For example factors of 40 are 1,2,4,5,8,10,20,40. See that SENSE OF CONSECUTIVENESS DECREASES AS WE MOVE FAR AWAY SINCE DIFFERENCE BETWEEN 
   FACTORS INCREASES AS WE MOVE FROM LEFT TO RIGHT. So maximum length of consecutive factors WILL SURELY APPEAR AT THE BEGINNING.

EXAMPLE - https://codeforces.com/problemset/problem/1855/B
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3. To claculate gcd of list of numbers stored in vector, we can find pair wise gcd. Result will be same.
        int ans = 0;
        for (int i = 1; i <= n; ++i)
        {
            int x;
            cin >> x;
            ans = __gcd(ans, abs(x-i));
        }

    https://codeforces.com/problemset/problem/1828/B
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4. Suppose you got a question in which manupulation of division and multiplication is required- in that case try analyzing its prime factors.
   https://codeforces.com/problemset/problem/1374/B
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
5. Whenever you encounter a problem that involves maximizing distances within a rectangular grid, especially with constraints on movement to adjacent cells:the optimal strategy involves placing 
   these points in opposite corners of the grid. This is because the longest possible distance in a rectangular grid is achieved by traversing the perimeter of the grid from one corner to the
   opposite corner.  (the distance always being 2⋅(n−1)+2⋅(m−1)).

   https://codeforces.com/problemset/problem/1537/B   -   (In this question output of test cases are incorrectly given)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
6. For two numbers a and b, if you want to maximize the gcd of a and b by simultaneously increasing OR decreasing(either one of them) a and b by 1, then maximum gcd possible is abs(a-b)

   https://codeforces.com/problemset/problem/1543/A
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
7. For 32-bit integers, use int or int32_t.
   For 64-bit integers, use long long or int64_t.
   For unsigned 32-bit integers, use uint32_t.  (In C++, the unsigned keyword is used to declare an integer type that can only represent non-negative values.)
   For unsigned 64-bit integers, use uint64_t.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
8. PRIME FACTORIZATION :- 

   #include<bits/stdc++.h>
    using namespace std;

const int N = 0;

void findPrimeFactors(long long n){
    vector<long long> x;
    //the smallest divisor of a number is always prime except 1
    for (long long i = 2; i*i <= n ; ++i)
    {
        while(n% i == 0){
            x.push_back(i);
            n = n/i;
        }
    }
    // if n == 1 it means n has only even factors
    if(n > 1) x.push_back(n);
    for(auto a : x){
        cout << a << " ";
    }
}


int main() {
    long long n;
    cin >> n;
    findPrimeFactors(n);
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

9. For finding divisors iterate from 1 to root n for each number i in this range. Check if i is divisor of n, if i is divisor then n/i is also a divisor. Collect both i and n/i as 
   divisor. Handle the edge case when both i and n/i is same to avoid duplicates(it can be done using sets).

  Shortcut to check if a number has odd divisor:-
  // Function to check if n has an odd divisor greater than 1
bool hasOddDivisorGreaterThanOne(long long n) {
    // Keep dividing n by 2 while it is even
    while (n % 2 == 0) {
        n /= 2;
    }
    // After all divisions by 2, if n becomes 1, it had no odd divisors
    // If n is greater than 1, it means there was an odd divisor
    return n > 1;
}
    https://codeforces.com/problemset/problem/1475/A
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10. [(a+b)/x] <= [a/x]+[b/x]
    [] - round it up to the nearest integer

    https://codeforces.com/problemset/problem/1471/A
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

