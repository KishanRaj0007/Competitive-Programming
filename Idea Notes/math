
1. For questions related to parity(odd, even), try to come up with solution by analyzing odd as 1 and even as 0. For example in an array having even frequency of odd numbers, it is always
  possible to divide array in two parts such that sum of both parts will have same parity.

  EXAMPLE - https://codeforces.com/problemset/problem/1857/A
  In case of binary string, if you replace 0 with -1 and 1 with 1, then substring which makes sum 0 is having same number of 0 and 1.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. To find the length of largest interval  [l,r](which isr-l+1) of positive integers(consecutive) such that, for every i in the interval (i.e., l≤i≤r), n is a multiple of i or i is a factor of n,
   we will simplify the problem by focussing on intervals starting from 1. If you find smallest integer x that does not divide n then the length of interval [1, x-1] which is ((x-1) - 1 +1) = x-1
   is the required length.
   In other words among a list of factors of a numbers, chances of getting maximum length of consecutive factors that divide a number is good if we start from beginning, this is because as 
   we move ahead difference between factors increase. For example factors of 40 are 1,2,4,5,8,10,20,40. See that SENSE OF CONSECUTIVENESS DECREASES AS WE MOVE FAR AWAY SINCE DIFFERENCE BETWEEN 
   FACTORS INCREASES AS WE MOVE FROM LEFT TO RIGHT. So maximum length of consecutive factors WILL SURELY APPEAR AT THE BEGINNING.

EXAMPLE - https://codeforces.com/problemset/problem/1855/B
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3. To claculate gcd of list of numbers stored in vector, we can find pair wise gcd. Result will be same.
        int ans = 0;
        for (int i = 1; i <= n; ++i)
        {
            int x;
            cin >> x;
            ans = __gcd(ans, abs(x-i));
        }

    https://codeforces.com/problemset/problem/1828/B
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4. Suppose you got a question in which manupulation of division and multiplication is required- in that case try analyzing its prime factors.
   https://codeforces.com/problemset/problem/1374/B
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
5. Whenever you encounter a problem that involves maximizing distances within a rectangular grid, especially with constraints on movement to adjacent cells:the optimal strategy involves placing 
   these points in opposite corners of the grid. This is because the longest possible distance in a rectangular grid is achieved by traversing the perimeter of the grid from one corner to the
   opposite corner.  (the distance always being 2⋅(n−1)+2⋅(m−1)).

   https://codeforces.com/problemset/problem/1537/B   -   (In this question output of test cases are incorrectly given)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
6. For two numbers a and b, if you want to maximize the gcd of a and b by simultaneously increasing OR decreasing(either one of them) a and b by 1, then maximum gcd possible is abs(a-b)

   https://codeforces.com/problemset/problem/1543/A
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
7. For 32-bit integers, use int or int32_t.
   For 64-bit integers, use long long or int64_t.
   For unsigned 32-bit integers, use uint32_t.  (In C++, the unsigned keyword is used to declare an integer type that can only represent non-negative values.)
   For unsigned 64-bit integers, use uint64_t.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------






